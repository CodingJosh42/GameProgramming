# Entwicklungsblog

## 20.04.2021
In den vergangenen Tagen habe ich über meine Idee für ein Spiel nachgedacht und reifen lassen. Nun bin ich zu der folgenden Idee gekommen: Es soll ein Spiel werden, in dem der Spieler eine Figur mit der Hilfe der WASD Tasten steuern kann. Dabei handelt es sich um eine 2D Umgebung, in der sich der Spieler von links nach rechts bewegen kann. Allerdings gibt es mehrere Ebenen. Das heißt die Figur kann auf eine höhere Ebene springen und auch wieder eine Ebene tiefer fallen. Die Figur hat eine Waffe, welche Projektile abschießen kann. Diese sollten genutzt werden um die computergesteuerten Gegner zu besiegen. Allerdings können die Gegner auch Projektile abfeuern und damit den Spieler treffen wenn er nicht ausweicht. Bei zu vielen Treffern hat der Spieler verloren. Das Ziel des Spielers ist es eine gewisse Ziellinie/-abschnitt zu erreichen. Als besondere Mechanik des Spiels soll es bestimmte Tore geben. Wenn der Spieler durch eines dieser Tore läuft ist er invertiert. Das heißt, wenn er nach links mit A laufen will, läuft er nach rechts. Die eigentliche Mechanik besteht nun darin, dass auch das Schießen "rückwärts" funktioniert. In dem normalen Zustand beginnen die Projektile bei der Waffe des Spielers und enden am Bildschirmrand. Im invertierten Zustand beginnen die Projektile am Bildschirmrand und enden bei der Waffe des Spielers. Durch eine gute Strukturierung des Levels soll der Spieler bestimmte Gegner nur im invertierten Modus besiegen können.

## 02.05.2021
Heute habe ich die allgemeine Main-Loop und den Anfang der Klasse Game implementiert. In der Main-Loop wird im Prinizip nichts anderes gemacht als Funktionen der Game Klasse aufzurufen. Dabei muss vor der Main-Loop die init-Funktion ausgeführt werden, welche SDL initialisiert und ein Window erstellt. In der Main-Loop werden nun, solange game->running True zurückliefert, immer wieder die Funktionen handleEvents(), update() und render() ausgeführt. All diese drei Funktion machen allerdings noch nicht viel. HandleEvents behandelt z.B. nur das Event, welches durch das Schließen der Anwendung ausgelöst wird. Sollte die Anwendung geschlossen werden wird die Main-Loop unterbrochen und die clear Funktion gibt belegten Speicher wieder frei.

## 05.05.2021
Heute habe ich mit der Hilfe von Pixel Edit einen ersten Entwurf eines Spielcharakters entwickelt. Diesen habe ich anschließend versucht in meine Anwendung mit einzubinden. Dazu habe ich die Klasse TextureManager definiert, welche die statische Methode LoadTexture besitzt. Diese soll dazu dienen, dass weitere Texturen in Zukunft schnell und einfach geladen werden können. Um meinen Spieler zu laden habe die soeben genannte Funktion in der init Funktion von Game aufgerufen. Damit die Texture gerendert wird, wird die Funktion renderCopy verwendet. Außerdem habe ich dieser Funktion ein SDL_Rect als "Destination-Rechteck" mitgegeben. Dadurch kann ich in meiner update-Funktion die Postion meiner Figur ändern, sodass sie jetzt immer wieder von links nach rechts durch das Fenster läuft. 

<img src="assets/player.png" alt="Figur" width="200" height="200" />

## 10.05.2021
Heute habe ich die Klasse GameObject erstellt. Mit der Hilfe dieser Klasse wird die Logik eines Spielobjektes gebündelt. Dadurch können später viele Objekte einfach erstellt werden und z.B. in einem Vektor abgespeichert werden. Die Klasse gameObject beinhaltet die Funktion update() und render(). Diese beiden Funktionen können dann in der Game Klasse in den jeweiligen Funktionen aufgerufen werden. Sind nun alle Objekte in einem Vektor gespeichert kann man über die Liste iterieren und für alle Objekte die Funktionen ausführen. Dem Konstruktor der Klasse kann man den Path zu der jeweiligen Texture und die Startposition des Objektes mitgeben. Des Weiteren habe ich einen ersten Entwurf einer Tilemap erstellt. 

<img src="assets/tilemap.PNG" alt="Tilemap" width="800" height="640" />

## 11.05.2021
Am 11.05. habe ich das Entity-Component-System implementiert. Dies soll die GameObjekt Klasse ersetzen, damit Entitys, also Objekte die platziert werden einfacher zu steuern sind und ihnen neue Eigenschaften zugewiesen werden können. Diese Steuerung der Entitys wird durch Components erreicht. Bei der Erstellung der Entitys können den Objekten die gewünschten Komponenten zugewiesen werden. Beispielsweise die TransformComponent. In dieser Komponente wird abgespeichert wo sich die Entity aktuell befindet. Ein weiteres Beispiel ist die SpriteComponent. Diese Komponente speichert die Texture des Objektes ab und sorgt dafür, dass die Texture gerendert wird. Neben der Entity Klasse und den Component Klassen gehört auch der Manager zu dem Entity-Component-System. Die Aufgabe des Managers ist es alle Entitys zu verwalten. Dazu werden alle Entitys in einer Liste gespeichert. In jedem Durchlauf der Mainloop wird in der update-Funktion der Klasse Game überprüft, ob noch alle Entitys in der Liste aktiv sind. Sollte eine Entity nicht mehr aktiv sein wird sie gelöscht. Des Weiteren wird für jede Entity die update Funktion aufgerufen, welche wiederum die update-Funktionen der Components aufruft. Das gleiche passiert jeweils mit der draw Funktion in der gleichnamingen Funktion in der Game Klasse.

## 12.05.2021
Heute habe ich meinen Spielcharakter um die KeyboardComponent Klasse erweitert. In dieser Klasse werden die Inputs der Tastatur in der Form von Events behandelt. Mit der Hilfe der KeyboardCompoent soll man nun die Figur mit der Hilfe von WASD steuern können. Für die Umsetzung muss der TransformComponent eine Geschwindigkeits-/Movementvariable zugewiesen werden. Diese wird in der Update Funktion der Komponente berücksichtigt. In der Keyboard Komponente behandelt man nun die Inputs mit einem switch-case-Statement. Ist der Input z.B. d (nach rechts laufen) wird der Transform Komponente als Movement in x-Richtung eine 1 zugewiesen. Für die anderen Richtungen müssen diese Werte natürlich angepasst werden. Dieses switch-case-Statement muss einmal für ein KEY_DOWN und ein KEY_UP Event durchgeführt werden (mit anderen Aktionen). Das zuvor genannte Beispiel mit d wird zum Beispiel bei einem KEY_DOWN Event (wenn die Taste gedrückt wird) durchgeführt. Bei einem KEY_UP Event (wenn die Taste losgelassen wird) müsste hingegen bei der Eingabe d die Bewegung in x-Richtung wieder auf 0 gesetzt werden, weil der Spieler nicht weiter nach rechts möchte. Zudem muss eine Schwerkraft implementiert werden, damit der Charakter springen kann und nicht irgendwo herumfliegt.

## 20.05.2021
In der vergangenen Woche habe ich mich mit Kollisionen auseinandergesetzt. Natürlich wurde dazu wieder eine Component erstellt. Die CollidersComponent speichert im Prinzip nur die "Hitbox" des Objektes ab. Dafür wird natürlich die Transform Component des Objektes gebraucht. Deshalb wird in der ColliderComponent sichergestellt, dass das Objekt aufjedenfall eine TransformComponent besitzt. Die Collision Klasse benutzt nun diese Collider Components um eine Kollision festzustellen. Momentan wird nur der einfachste Fall einer Kollision überprüft, nämlich die sogenannte AABB Kollision. Bei dieser Art von Kollision wird überprüft, ob die Rechtecke zweier Objekte (A und B) überlappen. Diese Methode funktioniert allerdings nur wenn die Objekte nicht rotiert wurden (was sie im Moment sowieso nicht sind). In der update-Funktion von Game wird nun stetig nach Kollisionen geschaut. Sollte eine Kollision stattfinden, wird der Player zurückgestoßen.

## 21.05.2021
Heute habe ich mich mit den Tiles, also den einzelnen Elementen der Map befasst. Dafür habe ich wieder eine neue Component erstellt. Als Parameter werden dem Konstruktor die x,y Position, die Breite und Länge und die ID des Tiles übergeben. Die ID wird benötigt um das passende Bild zu laden. Die annderen 4 Parameter werden für die Positionierung des Objektes genutzt. In der Init Funktion wird dem Objekt nun zusätzlich eine Transform Component und eine Sprite Component hinzugefügt. Mit der Hilfe des TileComponent habe ich anschließend meine Map Klasse verändert. Nun werden in der loadMap Funktion die Tiles als Entitys erstellt und ihnen wird eine TileComponent zugewiesen. Dadurch werden sie in der Liste von Entities in der Manager Klasse abgespeichert und durch die draw Funktion des Managers automatisch gerendert. Allerdings kann es nun passieren, dass die Player Figur und Enemy Figur nicht mehr gerendert werden, da die Tiles nach den jeweiligen Entities gerendert werden und diese überschreiben. Um sicherzustellen, dass dies nicht passiert habe ich Gruppen entworfen. Im Prinzip wird wird jeder Entity eine Zahl aus einem groupLabel Enum zugwiesen. Zusätzlich wird im Manager eine Gruppenliste gepflegt. Diese Liste speichert Listen von Entities ab. Die Entities in einer Liste gehören entsprechend zu einer Gruppe. Nun werden in der render Funktion der Klasse Game die Gruppen in der Reihenfolge gerendert wie es gewollt ist. In meinem Fall wären das zuerst die Tiles, dann der Player und anschließend die Enemys.

## 26.05.2021
Heute habe ich mich mit Animationen beschäftigt, beziehungsweise mit den Animationen meiner Figur. Dazu habe ich ein Sprite Sheed von meiner Figur entworfen. Darin habe ich verschiedene Bewegungen versucht zu visualisieren (es sieht noch etwas komisch aus). Zum Beispiel habe ich in einer Reihe meine gehende Figur gezeichnet und in einer anderen meine Figur wenn sie steht. Damit es etwas ansprechender aussieht soll meine Figur nämlich ein wenig in die Knie gehen und wieder hoch wenn sie sich nicht bewegt. Außerdem gibt es eine Animation für meine Figur in der Hocke und ein einzelnes Bild für meine Figur beim Springen. Dieses Sprite Sheet habe ich schließlich in meiner Sprite Component mit eingebunden. Dafür habe ich die Klasse Animation erstellt, welche die Zeile im Bild (index), die Anzahl der Frames und die Verzögerung zwischen den Frames abspeichert für die jeweilige Animation abspeichert. Die Klasse nutze ich dann im Konstruktor der Sprite Klasse, welcher bei Sprites mit Animationen aufgerufen wird (überladen). Für die verschiedenen Bewegungen wird jeweils ein Animationsobjekt erstellt und in einer Map abgespeichert. In der Update Funktion wird dann das passende Bild ausgewählt. Der x Wert des source Rechteckes wird mit folgender Formel berechnet: (Ticks in Millisekunden / delay) % frames) * breite. Um nun auch noch die passende Zeile auszuwählen wird der Index der Animation benutzt: höhe * index. Bei Sprites die nicht animiert werden ist der Index standardmäßig 0, sodass sich für diese Sprites nichts ändert. Der Funktion setAnimation kann man nun einen String übergeben, welcher als Key in der Animationsmap dient. Je nachdem welchen String man übergibt wird die entsprechende Animation ausgewählt. Des Weiteren habe ich meinen Keyboard Controller überarbeitet. Ich habe zum Beispiel SDL_RenderFlip benutzt um meine Texturen zu spiegeln. Zuvor habe ich das aufwändiger jeweils mit einem unterschiedlichen Asset erreicht. Außerdem habe ich die Update Funktion etwas refactored damit sie übersichtlicher und leichter zu ändern ist.

<img src="assets/animation_player.png" alt="SpriteSheet" width="800" height="640" />
